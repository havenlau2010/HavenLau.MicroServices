## 实体状态
`数据库上下文跟踪内存中的实体是否与数据库中相应的行同步，并且此信息确定调用 SaveChanges 方法时会发生的情况。 例如，将新实体传递到 Add 方法时，该实体的状态会设置为 Added。 然后调用 SaveChanges 方法时，数据库上下文发出 SQL INSERT 命令。
实体可能处于以下状态之一：
1. Added。 数据库中尚不存在实体。 SaveChanges 方法发出 INSERT 语句。
2. Unchanged。 不需要通过 SaveChanges 方法对此实体执行操作。 从数据库读取实体时，实体将从此状态开始。
3. Modified。 已修改实体的部分或全部属性值。 SaveChanges 方法发出 UPDATE 语句。
4. Deleted。 已标记该实体进行删除。 SaveChanges 方法发出 DELETE 语句。
5. Detached。 数据库上下文未跟踪该实体。`

## 实体导航加载：
1. 预先加载。 读取该实体时，会同时检索相关数据。 此时通常会出现单一联接查询，检索所有必需数据。 可使用 Include 和 ThenInclude 方法指定 Entity Framework Core 中的预先加载。
2. 可在单独查询中检索一些数据，EF 会“修正”导航属性。 也就是说，EF 会自动添加单独检索的实体，将其添加到之前检索的实体的导航属性中所属的位置。 对于检索相关数据的查询，可使用 Load 方法，而不采用返回列表或对象的方法，如 ToList 或 Single。
3. 显式加载。 首次读取实体时，不检索相关数据。 如有需要，可编写检索相关数据的代码。 就像使用单独查询进行预先加载一样，显式加载时会向数据库发送多个查询。 二者的区别在于，代码通过显式加载指定要加载的导航属性。 在 Entity Framework Core 1.1 中，可使用 Load 方法执行显式加载。
4. 延迟加载。 首次读取实体时，不检索相关数据。 然而，首次尝试访问导航属性时，会自动检索导航属性所需的数据。 每次首次尝试从导航属性获取数据时，都向数据库发送查询。 Entity Framework Core 1.0 不支持延迟加载。

## 性能注意事项
1. 如果知道自己需要每个检索的实体的相关数据，选择预先加载可获得最佳性能，因为相比每个检索的实体的单独查询，发送到数据库的单个查询更加有效。 
2. 另一方面，在某些情况下，单独查询会更加高效。 在一个查询中预先加载所有相关数据时，可能会生成一个非常复杂的联接，SQL Server 无法有效处理该联接。 或者，如果你正在处理一组实体且只需访问其子集的导航属性，那么采用单独查询可获得更佳性能，因为预先加载所有数据后，会检索不需要的数据。 

## bind特性
1. 基架生成了 Bind 特性，并将模型绑定器创建的实体添加到具有 Modified 标记的实体集。 不建议将该代码用于多个方案，因为 Bind 特性将清除未在 Include 参数中列出的字段中的任何以前存在的数据。
2. Entity Framework 的自动更改跟踪在由表单输入更改的字段上设置 Modified 标记。 调用 SaveChanges 方法时，Entity Framework 会创建 SQL 语句，以更新数据库行。 忽略并发冲突，并且仅在数据库中更新由用户更新的表列。

## EF 解析



		``` 
		_context.Students.Remove(student);
		await _context.SaveChangesAsync();
		```
		

1. 此代码检索所选的实体，然后调用 Remove 方法以将实体的状态设置为 Deleted。 
2. 调用 SaveChanges 时生成 SQL DELETE 命令。
3. 如果在大容量应用程序中提高性能是优先事项，则可以通过只使用主键值实例化 Student 实体，然后将实体状态设置为 Deleted 来避免不必要的 SQL 查询。 
4. 这是 Entity Framework 删除实体需要执行的所有操作。 

## 非跟踪查询

当数据库上下文检索表行并创建表示它们的实体对象时，默认情况下，它会跟踪内存中的实体是否与数据库中的内容同步。更新实体时，内存中的数据充当缓存并使用该数据。 在 Web 应用程序中，此缓存通常是不必要的，因为上下文实例通常生存期较短（创建新的实例并用于处理每个请求），并且通常在再次使用该实体之前处理读取实体的上下文。可以通过调用 `AsNoTracking` 方法禁用对内存中的实体对象的跟踪。 可能想要执行的典型方案包括以下操作：

1. 在上下文生存期内，不需要更新任何实体，并且不需要 EF 自动加载具有由单独的查询检索的实体的导航属性。 在控制器的 HttpGet 操作方法中经常遇到这些情况。
2. 正在运行检索大量数据的查询，将只更新一小部分返回的数据。 关闭对大型查询的跟踪可能更有效，稍后为少数需要更新的实体运行查询。
3. 想要附加一个实体来更新它，但之前为了其他目的，已检索了相同的实体。 由于数据库上下文已跟踪了该实体，因此无法附加要更改的实体。 处理这种情况的一种方法是在早前的查询上调用 `AsNoTracking`。

## DataAnnotations
1. Required 特性

   Required 特性使名称属性成为必填字段。 值类型（DateTime、int、double、float 等）等不可为 null 的类型不需要 Required 特性。 系统会将不可为 null 的类型自动视为必填字段。

   可删除 `Required` 特性，并用 `StringLength` 特性的最小长度参数来替换

2. Display 特性
     Display 特性指定文本框的标题应是“名”、“姓”、“全名”和“注册日期”，而不是每个实例中的属性名称（其中没有分隔单词的空格）
3. FullName 计算属性
     FullName 是计算属性，可返回通过串联两个其他属性创建的值。 因此它只有一个 get 访问器，且数据库中不会生成 FullName 列
4. 导航属性

   - one-many 一名讲师可以教授任意数量的课程，因此 `CourseAssignments` 定义为集合。

     public ICollection<CourseAssignment> CourseAssignments { get; set; }

   - 

5. 


```
https://docs.microsoft.com/zh-cn/aspnet/core/data/ef-mvc/complex-data-model?view=aspnetcore-2.1
```